var M11_PRAG_STATE_PRAG_BELIEF = function(){

  	var speakerOptimality = {
  		alpha_1 : uniformDrift({a: 0, b: 20, width: 2}),
      alpha_2 : uniformDrift({a: 0, b: 10, width: 2})
  	}

    var noise = uniformDrift({a: 0, b: 0.1, width: 0.01})

    var regionProbs = repeat(7, function(){ return uniformDrift({a: 0, b: 1, width: 0.1}) })
    var firstTermPrefWeight  = uniformDrift({a: 1, b: 5, width: 0.5})
    var nvcWeight = 1
  	var VennPrior = makeVennPrior(regionProbs)

	  var venn_interpreter = cache(function(sentences) {
	    Infer({
	      model: function() {
	        var venn = sample(VennPrior)
	        foreach(sentences, function(utterance) {
	          var meaningFn = lexicon[utterance.quantifier]
	          condition(
	            flip(noise) ? true :
	            meaningFn(venn, utterance.p1, utterance.p2)
	          )
	        })
	        return vennToString(venn)
	      },
	      method: "enumerate"
	    })
	  }, 10000)

	  var argument_speaker = cache(function(qudVal, observed_premises) {
	    Infer({
	      model: function() {
	        var alternative_fn_double = alternative_set.double
	        var alternative_fn_single = alternative_set.single
	        var premises = observed_premises.length == 2 ?
	          map(sample,  alternative_fn_double(observed_premises)) :
	          [sample(alternative_fn_single(observed_premises[0]))]
	        var LiteralDist = venn_interpreter(premises)
	        factor(speakerOptimality.alpha_1 * LiteralDist.score(qudVal))
	        return premises
	      },
	      method: "enumerate"
	    })
	  }, 10000)


	  var pragmatic_interpreter = cache(function(premises) {
	    Infer({
	      model: function() {
	        var venn = sample(VennPrior)
	        var qudVal = vennToString(venn)
	        var SpeakerDist = argument_speaker(qudVal, premises)
	        observe(SpeakerDist, premises)
	        return vennToString(venn)
	      },
	      method: "enumerate"
	    })
	  }, 10000)


	  var conclusion_model = function(premises){
			var first_term_preference = firstTermPreference(premises) // A, C, or false
			var prms = {nvcWeight, firstTermPrefWeight}
		  var ConclusionPrior = makeConclusionPrior(first_term_preference, prms)
	    var PremiseInterpretation = pragmatic_interpreter(premises)

	    var conclusionDist = Infer({model: function(){
	      var conclusion = sample(ConclusionPrior)
				var ConclusionInterpretation = venn_interpreter([conclusion])
				var _kl = KL(
	        PremiseInterpretation,
	        ConclusionInterpretation,
	        PremiseInterpretation.support()
	      )
	      factor(speakerOptimality.alpha_2 * -1 * _kl)

	      return formatSentence(conclusion)
	    }})

	    return conclusionDist

	  }


  	foreach(premise_1s, function(prem_1){
  			foreach(premise_2s, function(prem_2){
          var data_filtered = _.filter(df_clean, {prem_1, prem_2})
  				var syllogisticPremises = [prem_1, prem_2]
          var rsaPredictions = conclusion_model(syllogisticPremises)
          mapData({data: _.map(data_filtered, "conclusion")}, function(d){
            var scr = rsaPredictions.score(d)
            scr == -Infinity ? display(formatSentence(prem_1) + " _ " + formatSentence(prem_2) + " _ " + d) : null

            observe(rsaPredictions, d)
          })

  				foreach(rsaPredictions.support(), function(s){

  					query.add(
  						["prediction", formatSentence(prem_1), formatSentence(prem_2), s],
  						Math.exp(rsaPredictions.score(s))
  					)
  				})
  			})
  	})

  	query.add(["parameter", "speakerOptimality", "alpha_1", -99], speakerOptimality.alpha_1)
  	query.add(["parameter", "speakerOptimality", "alpha_2", -99], speakerOptimality.alpha_2)
  	query.add(["parameter", "noise", -99, -99], noise)
  	query.add(["parameter", "firstTermPreference", -99, -99], firstTermPrefWeight)
  	query.add(["parameter", "nvcWeight", -99, -99], nvcWeight)

  	var xkh = map2(function(region, priorProb) {
  		var regionLabel = parseVennDiagram(region)
  		query.add(["parameter", "statePrior", regionLabel, -99], priorProb)
  	}, regions, regionProbs)

  	return query

  }
