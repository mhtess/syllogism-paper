var M00_LIT_LIT = function(){

  var speakerOptimality = {
		alpha_1 : -99,
    alpha_2 : uniformDrift({a: 0, b: 10, width: 2})
	}
  var noise = uniformDrift({a: 0, b: 0.1, width: 0.01})
	
	var regionParams = {
		"A_B_C_AB_BC_AC_ABC": 0.5 //uniformDrift({a: 0, b: 1, width: 0.1})
	}

	// C, B, BC, A,  AC, AB, ABC
	var regionProbs = [
		regionParams.A_B_C_AB_BC_AC_ABC,
		regionParams.A_B_C_AB_BC_AC_ABC,
		regionParams.A_B_C_AB_BC_AC_ABC,
		regionParams.A_B_C_AB_BC_AC_ABC,
		regionParams.A_B_C_AB_BC_AC_ABC,
		regionParams.A_B_C_AB_BC_AC_ABC,
		regionParams.A_B_C_AB_BC_AC_ABC
	]

  var firstTermPrefWeight  = uniformDrift({a: 1, b: 5, width: 0.5})
  var nvcWeight = 1

	var VennPrior = makeVennPrior(regionProbs)

  var venn_interpreter = cache(function(sentences) {
    Infer({
      model: function() {
        var venn = sample(VennPrior)
        foreach(sentences, function(utterance) {
          var meaningFn = lexicon[utterance.quantifier]
          condition(
            flip(noise) ? true :
            meaningFn(venn, utterance.p1, utterance.p2)
          )
        })
        return venn
      },
      method: "enumerate"
    })
  }, 10000)

  var conclusion_model = function(premises){
		var first_term_preference = firstTermPreference(premises) // A, C, or false
		var prms = {nvcWeight, firstTermPrefWeight}
		var ConclusionPrior = makeConclusionPrior(first_term_preference, prms)

    var PremiseInterpretation = venn_interpreter(premises)
    var conclusionDist = Infer({model: function(){
      var venn = sample(PremiseInterpretation)
      var conclusion = sample(ConclusionPrior)
      var conclusionMeaningFn = lexicon[conclusion.quantifier]
      condition(conclusionMeaningFn(venn, conclusion.p1, conclusion.p2))
      return formatSentence(conclusion)
    }})

    return exponentiateRenormalize(conclusionDist, speakerOptimality.alpha_2)

  }


		foreach(premise_1s, function(prem_1){
				foreach(premise_2s, function(prem_2){
					var data_filtered = _.filter(df_clean, {prem_1, prem_2})
					var syllogisticPremises = [prem_1, prem_2]
					var rsaPredictions = conclusion_model(syllogisticPremises)

					mapData({data: _.map(data_filtered, "conclusion")}, function(d){
						var scr = rsaPredictions.score(d)
						scr == -Infinity ? display(
							formatSentence(prem_1) + " _ " + formatSentence(prem_2) + " _ " + d
						) : null

						observe(rsaPredictions, d)
					})

					foreach(rsaPredictions.support(), function(s){

						query.add(
							["prediction", formatSentence(prem_1), formatSentence(prem_2), s],
							Math.exp(rsaPredictions.score(s))
						)
					})
				})
		})

		query.add(["parameter", "speakerOptimality", "alpha_2", -99], speakerOptimality.alpha_2)
		query.add(["parameter", "noise", -99, -99], noise)
		query.add(["parameter", "firstTermPreference", -99, -99], firstTermPrefWeight)
		query.add(["parameter", "nvcWeight", -99, -99], nvcWeight)

		var xkh = map2(function(region, priorProb) {
			var regionLabel = parseVennDiagram(region)
			query.add(["parameter", "statePrior", regionLabel, -99], priorProb)
		}, regions, regionProbs)

		return query

}
